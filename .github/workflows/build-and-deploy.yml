name: Build and Deploy

on:
  push:
    branches:
      - develop
      - main
  pull_request:
    branches:
      - develop
      - main

env:
  TERRAFORM_VERSION: '1.6.0'
  ANSIBLE_VERSION: '10.5.0'

jobs:
  # Job de build - Toujours exÃ©cutÃ© (mÃªme dans les PRs)
  build:
    name: Build and Validate
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        run: |
          echo "ðŸ” Checking Terraform format..."
          terraform fmt -check -recursive terraform/
        continue-on-error: true

      - name: Terraform Validate (Dev)
        working-directory: terraform/environments/dev
        run: |
          echo "âœ… Validating Dev environment..."
          terraform init -backend=false
          terraform validate

      - name: Terraform Validate (Prod)
        working-directory: terraform/environments/prod
        run: |
          echo "âœ… Validating Prod environment..."
          terraform init -backend=false
          terraform validate

      - name: Validate Kubernetes Manifests
        run: |
          echo "ðŸ” Validating Kubernetes manifests..."
          
          # Install kustomize
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          
          # Validate dev overlay
          echo "Validating dev overlay..."
          kustomize build k8s/overlays/dev > /dev/null
          
          # Validate prod overlay
          echo "Validating prod overlay..."
          kustomize build k8s/overlays/prod > /dev/null
          
          echo "âœ… All manifests are valid"

      - name: Validate Ansible Playbooks
        run: |
          echo "ðŸ” Validating Ansible playbooks..."
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          ansible-playbook ansible/deploy.yml --syntax-check
          ansible-playbook ansible/destroy.yml --syntax-check
          echo "âœ… All playbooks are valid"

      - name: Build Summary
        run: |
          echo "## ðŸŽ‰ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Terraform configuration valid" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Kubernetes manifests valid" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Ansible playbooks valid" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "â„¹ï¸ **Pull Request** - Deployment skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš€ **Branch: ${{ github.ref_name }}** - Deployment will proceed" >> $GITHUB_STEP_SUMMARY
          fi

  # DÃ©termine l'environnement basÃ© sur la branche
  set-environment:
    name: Set Environment
    runs-on: ubuntu-latest
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    needs: build
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Determine Environment
        id: set-env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "ðŸŒ Environment: **Production**" >> $GITHUB_STEP_SUMMARY
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "ðŸ§ª Environment: **Development**" >> $GITHUB_STEP_SUMMARY
          fi

  # VÃ©rification et gÃ©nÃ©ration des certificats
  check-certificates:
    name: Check and Generate Certificates
    runs-on: ubuntu-latest
    needs: set-environment
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check Certificates in Key Vault
        id: check-certs
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          KEY_VAULT_NAME="owncloudkv${ENVIRONMENT}"
          
          echo "ðŸ” Checking certificates in Key Vault: $KEY_VAULT_NAME"
          
          # VÃ©rifier si les certificats OCIS existent
          OCIS_CERT=1
          OCIS_KEY=0
          
          # VÃ©rifier ocis-tls-cert
          # if az keyvault certificate show --vault-name $KEY_VAULT_NAME --name ocis-tls-cert --query "name" -o tsv 2>/dev/null | grep -q "ocis-tls-cert"; then
          #   OCIS_CERT=1
          # fi
          
          # VÃ©rifier ocis-tls-key
          if az keyvault secret show --vault-name $KEY_VAULT_NAME --name ocis-tls-key --query "name" -o tsv 2>/dev/null | grep -q "ocis-tls-key"; then
            OCIS_KEY=1
          fi
          
          if [ "$OCIS_CERT" -gt 0 ] && [ "$OCIS_KEY" -gt 0 ]; then
            echo "âœ… All certificates already exist in Key Vault"
            echo "  - ocis-tls-cert: Found"
            echo "  - ocis-tls-key: Found"
            echo "certificates_exist=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Some certificates are missing in Key Vault"
            echo "  - ocis-tls-cert: $([ $OCIS_CERT -gt 0 ] && echo 'Found' || echo 'Missing')"
            echo "  - ocis-tls-key: $([ $OCIS_KEY -gt 0 ] && echo 'Found' || echo 'Missing')"
            echo "certificates_exist=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Self-Signed Certificates
        if: steps.check-certs.outputs.certificates_exist == 'false'
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          
          if [ "$ENVIRONMENT" == "prod" ]; then
            DOMAIN="prod.lesaiglesbraves.online"
          else
            DOMAIN="dev.lesaiglesbraves.online"
          fi
          
          echo "ðŸ” Generating self-signed certificates for $DOMAIN"
          
          # CrÃ©er le rÃ©pertoire pour les certificats
          mkdir -p certs
          
          # GÃ©nÃ©rer le certificat OCIS
          echo "Generating OCIS certificate..."
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout certs/ocis-tls.key \
            -out certs/ocis-tls.crt \
            -subj "/C=FR/ST=France/L=Paris/O=OwnCloud/OU=IT/CN=$DOMAIN" \
            -addext "subjectAltName=DNS:$DOMAIN,DNS:*.$DOMAIN"
          
          # CrÃ©er des fichiers PFX pour Azure Key Vault
          echo "Creating PFX files..."
          openssl pkcs12 -export -out certs/ocis-tls.pfx \
            -inkey certs/ocis-tls.key -in certs/ocis-tls.crt -passout pass:
          
          echo "âœ… Certificates generated successfully"

      - name: Upload Certificates to Key Vault
        if: steps.check-certs.outputs.certificates_exist == 'false'
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          KEY_VAULT_NAME="owncloudkv${ENVIRONMENT}"
          
          echo "ðŸ“¤ Uploading certificates to Key Vault: $KEY_VAULT_NAME"
          
          # Upload OCIS certificate
          echo "Uploading OCIS certificate..."
          az keyvault certificate import \
            --vault-name $KEY_VAULT_NAME \
            --name ocis-tls-cert \
            --file certs/ocis-tls.pfx
          
          az keyvault secret set \
            --vault-name $KEY_VAULT_NAME \
            --name ocis-tls-key \
            --file certs/ocis-tls.key \
            --content-type "application/x-pem-file"
          
          echo "âœ… All certificates uploaded successfully"
          
          # Nettoyer les fichiers locaux
          rm -rf certs

      - name: Certificate Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## ðŸ” Certificate Status - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.check-certs.outputs.certificates_exist }}" == "true" ]; then
            echo "âœ… Certificates already present in Key Vault" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ” New self-signed certificates generated and uploaded" >> $GITHUB_STEP_SUMMARY
          fi

  # DÃ©ploiement Terraform
  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [set-environment, check-certificates]
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    environment: ${{ needs.set-environment.outputs.environment }}
    env:
      ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
      ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
      ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
      ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸ”§ Initializing Terraform for ${{ needs.set-environment.outputs.environment }}..."
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          if [ "$ENVIRONMENT" = "prod" ]; then
            SA_NAME="owncloudsastateprod"
          else
            SA_NAME="owncloudsastatedev"
          fi
          terraform init \
            -backend-config="storage_account_name=$SA_NAME" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=owncloud.tfstate"

      - name: Terraform Plan
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸ“‹ Creating Terraform plan..."
          terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸš€ Applying Terraform plan..."
          terraform apply -auto-approve tfplan

      - name: Get AKS Credentials
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "ðŸ”‘ Getting AKS credentials for $ENVIRONMENT..."
          az aks get-credentials \
            --resource-group owncloud-rg-$ENVIRONMENT \
            --name owncloud-aks-$ENVIRONMENT \
            --overwrite-existing

      - name: Infrastructure Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## ðŸ—ï¸ Infrastructure Deployed - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… AKS Cluster: owncloud-aks-$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Resource Group: owncloud-rg-$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Key Vault: owncloudkv$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Storage Account: owncloudstorages$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY

  # DÃ©ploiement des applications
  deploy-apps:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [set-environment, terraform]
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    environment: ${{ needs.set-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Ansible
        run: |
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          ansible-galaxy collection install kubernetes.core
          ansible-galaxy collection install azure.azcollection

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          az aks get-credentials \
            --resource-group owncloud-rg-$ENVIRONMENT \
            --name owncloud-aks-$ENVIRONMENT \
            --overwrite-existing

      - name: Clean up old resources
        run: |
          echo "ðŸ§¹ Cleaning up old SecretProviderClass and secrets..."
          
          # Supprimer les anciennes SecretProviderClass (sauf ocis-keyvault-certs)
          kubectl delete secretproviderclass ocis-tls -n owncloud --ignore-not-found=true
          
          # Supprimer le pod de sync s'il existe dÃ©jÃ 
          kubectl delete pod secrets-sync-pod -n owncloud --ignore-not-found=true
          
          # Attendre que les ressources soient supprimÃ©es
          sleep 10
          
          echo "âœ… Cleanup completed"

      - name: Deploy Applications with Ansible
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "ðŸš€ Deploying applications to $ENVIRONMENT..."
          
          ansible-playbook \
            -i ansible/inventories/$ENVIRONMENT.yml \
            ansible/deploy.yml \
            -e "target_env=$ENVIRONMENT"

      - name: Generate and Set Application Secrets
        run: |
          echo "ðŸ” Generating random secrets for applications..."
          
          # GÃ©nÃ©rer des secrets alÃ©atoires
          JWT_SECRET=$(openssl rand -base64 32)
          OCIS_ADMIN_PASSWORD=$(openssl rand -base64 24)
          
          # Patcher le secret ocis-secret
          kubectl patch secret ocis-secret -n owncloud --type='json' -p='[
            {"op": "replace", "path": "/data/admin-password", "value": "'$(echo -n "$OCIS_ADMIN_PASSWORD" | base64 -w0)'"},
            {"op": "replace", "path": "/data/jwt-secret", "value": "'$(echo -n "$JWT_SECRET" | base64 -w0)'"}
          ]'
          
          echo "âœ… Secrets generated and applied"
          echo "âš ï¸ Save these credentials securely:"
          echo "- OCIS Admin Password: $OCIS_ADMIN_PASSWORD"

      - name: Wait for Deployments
        run: |
          echo "â³ Waiting for secrets sync and applications to be ready..."
          
          # Afficher l'Ã©tat actuel
          echo ""
          echo "=== Current pods status ==="
          kubectl get pods -n owncloud
          
          echo ""
          echo "=== Checking secrets ==="
          kubectl get secrets -n owncloud
          
          echo ""
          echo "=== Checking SecretProviderClass ==="
          kubectl get secretproviderclass -n owncloud
          
          # VÃ©rifier si le secrets-sync-pod existe et diagnostiquer
          echo ""
          echo "=== Diagnosing secrets-sync-pod ==="
          if kubectl get pod secrets-sync-pod -n owncloud &>/dev/null; then
            echo "Pod exists, checking status..."
            kubectl describe pod secrets-sync-pod -n owncloud | grep -A 20 "Events:"
            
            # Si le pod est en erreur, afficher les logs
            POD_STATUS=$(kubectl get pod secrets-sync-pod -n owncloud -o jsonpath='{.status.phase}')
            echo "Pod status: $POD_STATUS"
            
            if [ "$POD_STATUS" != "Running" ]; then
              echo ""
              echo "âš ï¸ secrets-sync-pod is not running. Recent events:"
              kubectl get events -n owncloud --field-selector involvedObject.name=secrets-sync-pod --sort-by='.lastTimestamp'
            fi
          else
            echo "âš ï¸ secrets-sync-pod does not exist!"
          fi
          
          # Attendre que les secrets TLS soient crÃ©Ã©s (max 5 minutes)
          echo ""
          echo "=== Waiting for TLS secrets to be created ==="
          TIMEOUT=300
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if kubectl get secret ocis-tls -n owncloud &>/dev/null; then
              echo "âœ… TLS secrets are ready!"
              break
            fi
            echo "Waiting for secrets... (${ELAPSED}s/${TIMEOUT}s)"
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "âŒ Timeout waiting for TLS secrets!"
            echo "Checking CSI driver logs..."
            kubectl logs -n kube-system -l app=csi-secrets-store-provider-azure --tail=50 || echo "Could not get CSI driver logs"
            exit 1
          fi
          
          # Maintenant attendre que les applications soient prÃªtes
          echo ""
          echo "=== Waiting for application pods (timeout: 10 minutes) ==="
          kubectl wait --for=condition=ready pod -l app=ocis -n owncloud --timeout=600s || echo "âš ï¸ OCIS timeout"
          
          # Afficher le statut final
          echo ""
          echo "=== Final pod status ==="
          kubectl get pods -n owncloud
          
          # Afficher les logs des pods en erreur
          echo ""
          echo "=== Checking for pod errors ==="
          FAILED_PODS=$(kubectl get pods -n owncloud --field-selector=status.phase!=Running,status.phase!=Succeeded -o name 2>/dev/null || echo "")
          
          if [ -n "$FAILED_PODS" ]; then
            echo "âš ï¸ Some pods are not running:"
            echo "$FAILED_PODS"
            
            for POD in $FAILED_PODS; do
              POD_NAME=$(echo $POD | cut -d'/' -f2)
              if [[ ! "$POD_NAME" =~ "secrets-sync-pod" ]]; then
                echo ""
                echo "--- Logs for $POD_NAME ---"
                kubectl logs $POD_NAME -n owncloud --tail=50 || echo "Could not get logs"
              fi
            done
            
            echo ""
            echo "--- Recent events ---"
            kubectl get events -n owncloud --sort-by='.lastTimestamp' | tail -30
          fi
          
          echo ""
          echo "âœ… Deployment check completed"
          echo "âœ… All pods are ready!"

      - name: Get Service Information
        id: service-info
        run: |
          echo "ðŸ“Š Getting service information..."
          
          # Obtenir l'IP de l'Ingress
          INGRESS_IP=$(kubectl get ingress -n owncloud owncloud-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "ingress_ip=$INGRESS_IP" >> $GITHUB_OUTPUT
          
          # Lister tous les pods
          echo "### ðŸ“¦ Deployed Pods" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n owncloud >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Services" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n owncloud >> $GITHUB_STEP_SUMMARY

      - name: Deployment Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          INGRESS_IP="${{ steps.service-info.outputs.ingress_ip }}"
          
          if [ "$ENVIRONMENT" == "prod" ]; then
            DOMAIN="prod.lesaiglesbraves.online"
          else
            DOMAIN="dev.lesaiglesbraves.online"
          fi
          
          echo "## ðŸŽ‰ Deployment Successful - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Access Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain**: https://$DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "- **Ingress IP**: $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Update DNS record to point $DOMAIN to $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "2. Access ownCloud OCIS at https://$DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Note**: Self-signed certificate in use. For production, configure Let's Encrypt." >> $GITHUB_STEP_SUMMARY

  # Job de nettoyage en cas d'Ã©chec
  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [set-environment, terraform, deploy-apps]
    if: failure() && github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    steps:
      - name: Failure Notification
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## âŒ Deployment Failed - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The deployment has failed. Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Troubleshooting Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Check Terraform output for infrastructure errors" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify Azure credentials and permissions" >> $GITHUB_STEP_SUMMARY
          echo "3. Check Ansible playbook logs for application deployment errors" >> $GITHUB_STEP_SUMMARY
          echo "4. Review Kubernetes events: \`kubectl get events -n owncloud\`" >> $GITHUB_STEP_SUMMARY
