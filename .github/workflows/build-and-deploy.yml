name: Build and Deploy

on:
  push:
    branches:
      - develop
      - main
  pull_request:
    branches:
      - develop
      - main

env:
  TERRAFORM_VERSION: '1.6.0'
  ANSIBLE_VERSION: '10.5.0'

jobs:
  # Job de build - Toujours exÃ©cutÃ© (mÃªme dans les PRs)
  build:
    name: Build and Validate
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        run: |
          echo "ðŸ” Checking Terraform format..."
          terraform fmt -check -recursive terraform/
        continue-on-error: true

      - name: Terraform Validate (Dev)
        working-directory: terraform/environments/dev
        run: |
          echo "âœ… Validating Dev environment..."
          terraform init -backend=false
          terraform validate

      - name: Terraform Validate (Prod)
        working-directory: terraform/environments/prod
        run: |
          echo "âœ… Validating Prod environment..."
          terraform init -backend=false
          terraform validate

      - name: Validate Kubernetes Manifests
        run: |
          echo "ðŸ” Validating Kubernetes manifests..."
          
          # Install kustomize
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          
          # Validate dev overlay
          echo "Validating dev overlay..."
          kustomize build k8s/overlays/dev > /dev/null
          
          # Validate prod overlay
          echo "Validating prod overlay..."
          kustomize build k8s/overlays/prod > /dev/null
          
          echo "âœ… All manifests are valid"

      - name: Validate Ansible Playbooks
        run: |
          echo "ðŸ” Validating Ansible playbooks..."
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          ansible-playbook ansible/deploy.yml --syntax-check
          ansible-playbook ansible/destroy.yml --syntax-check
          echo "âœ… All playbooks are valid"

      - name: Build Summary
        run: |
          echo "## ðŸŽ‰ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Terraform configuration valid" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Kubernetes manifests valid" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Ansible playbooks valid" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "â„¹ï¸ **Pull Request** - Deployment skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš€ **Branch: ${{ github.ref_name }}** - Deployment will proceed" >> $GITHUB_STEP_SUMMARY
          fi

  # DÃ©termine l'environnement basÃ© sur la branche
  set-environment:
    name: Set Environment
    runs-on: ubuntu-latest
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    needs: build
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Determine Environment
        id: set-env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "ðŸŒ Environment: **Production**" >> $GITHUB_STEP_SUMMARY
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "ðŸ§ª Environment: **Development**" >> $GITHUB_STEP_SUMMARY
          fi

  # VÃ©rification et gÃ©nÃ©ration des certificats
  check-certificates:
    name: Check and Generate Certificates
    runs-on: ubuntu-latest
    needs: set-environment
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check Certificates in Key Vault
        id: check-certs
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          KEY_VAULT_NAME="owncloudkv${ENVIRONMENT}"
          
          echo "ðŸ” Checking certificates in Key Vault: $KEY_VAULT_NAME"
          
          # VÃ©rifier si les certificats existent
          CERT_EXISTS=$(az keyvault certificate list --vault-name $KEY_VAULT_NAME --query "length([?name=='tls-cert'])" -o tsv 2>/dev/null || echo "0")
          KEY_EXISTS=$(az keyvault secret list --vault-name $KEY_VAULT_NAME --query "length([?name=='tls-key'])" -o tsv 2>/dev/null || echo "0")
          
          if [ "$CERT_EXISTS" -gt 0 ] && [ "$KEY_EXISTS" -gt 0 ]; then
            echo "âœ… Certificates already exist in Key Vault"
            echo "certificates_exist=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Certificates not found in Key Vault"
            echo "certificates_exist=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Self-Signed Certificates
        if: steps.check-certs.outputs.certificates_exist == 'false'
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          
          if [ "$ENVIRONMENT" == "prod" ]; then
            DOMAIN="prod.lesaiglesbraves.online"
          else
            DOMAIN="dev.lesaiglesbraves.online"
          fi
          
          echo "ðŸ” Generating self-signed certificate for $DOMAIN"
          
          # CrÃ©er le rÃ©pertoire pour les certificats
          mkdir -p certs
          
          # GÃ©nÃ©rer la clÃ© privÃ©e
          openssl genrsa -out certs/tls.key 2048
          
          # GÃ©nÃ©rer le certificat auto-signÃ©
          openssl req -new -x509 -sha256 -key certs/tls.key -out certs/tls.crt -days 365 \
            -subj "/C=FR/ST=IDF/L=Paris/O=LesAiglesBraves/CN=$DOMAIN"
          
          echo "âœ… Certificate generated successfully"

      - name: Upload Certificates to Key Vault
        if: steps.check-certs.outputs.certificates_exist == 'false'
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          KEY_VAULT_NAME="owncloudkv${ENVIRONMENT}"
          
          echo "ðŸ“¤ Uploading certificates to Key Vault: $KEY_VAULT_NAME"
          
          # Convertir le certificat en base64 pour Key Vault
          CERT_CONTENT=$(cat certs/tls.crt | base64 -w 0)
          KEY_CONTENT=$(cat certs/tls.key | base64 -w 0)
          
          # Upload certificate
          az keyvault secret set \
            --vault-name $KEY_VAULT_NAME \
            --name tls-cert \
            --value "$CERT_CONTENT" \
            --content-type "application/x-pem-file"
          
          # Upload private key
          az keyvault secret set \
            --vault-name $KEY_VAULT_NAME \
            --name tls-key \
            --value "$KEY_CONTENT" \
            --content-type "application/x-pem-file"
          
          echo "âœ… Certificates uploaded successfully"
          
          # Nettoyer les fichiers locaux
          rm -rf certs

      - name: Certificate Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## ðŸ” Certificate Status - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.check-certs.outputs.certificates_exist }}" == "true" ]; then
            echo "âœ… Certificates already present in Key Vault" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ” New self-signed certificates generated and uploaded" >> $GITHUB_STEP_SUMMARY
          fi

  # DÃ©ploiement Terraform
  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [set-environment, check-certificates]
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    environment: ${{ needs.set-environment.outputs.environment }}
    env:
      ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
      ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
      ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
      ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸ”§ Initializing Terraform for ${{ needs.set-environment.outputs.environment }}..."
          terraform init \
            -backend-config="storage_account_name=tfstate${{ needs.set-environment.outputs.environment }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=owncloud.tfstate"

      - name: Terraform Plan
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸ“‹ Creating Terraform plan..."
          terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸš€ Applying Terraform plan..."
          terraform apply -auto-approve tfplan

      - name: Get AKS Credentials
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "ðŸ”‘ Getting AKS credentials for $ENVIRONMENT..."
          az aks get-credentials \
            --resource-group owncloud-rg-$ENVIRONMENT \
            --name owncloud-aks-$ENVIRONMENT \
            --overwrite-existing

      - name: Infrastructure Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## ðŸ—ï¸ Infrastructure Deployed - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… AKS Cluster: owncloud-aks-$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Resource Group: owncloud-rg-$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Key Vault: owncloudkv$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Storage Account: owncloudstorages$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY

  # DÃ©ploiement des applications
  deploy-apps:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [set-environment, terraform]
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    environment: ${{ needs.set-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Ansible
        run: |
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          ansible-galaxy collection install kubernetes.core
          ansible-galaxy collection install azure.azcollection

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          az aks get-credentials \
            --resource-group owncloud-rg-$ENVIRONMENT \
            --name owncloud-aks-$ENVIRONMENT \
            --overwrite-existing

      - name: Deploy Applications with Ansible
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "ðŸš€ Deploying applications to $ENVIRONMENT..."
          
          ansible-playbook \
            -i ansible/inventories/$ENVIRONMENT.yml \
            ansible/deploy.yml \
            -e "target_env=$ENVIRONMENT"

      - name: Wait for Deployments
        run: |
          echo "â³ Waiting for all pods to be ready..."
          kubectl wait --for=condition=ready pod --all -n owncloud --timeout=600s

      - name: Get Service Information
        id: service-info
        run: |
          echo "ðŸ“Š Getting service information..."
          
          # Obtenir l'IP de l'Ingress
          INGRESS_IP=$(kubectl get ingress -n owncloud owncloud-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "ingress_ip=$INGRESS_IP" >> $GITHUB_OUTPUT
          
          # Lister tous les pods
          echo "### ðŸ“¦ Deployed Pods" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n owncloud >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Services" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n owncloud >> $GITHUB_STEP_SUMMARY

      - name: Deployment Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          INGRESS_IP="${{ steps.service-info.outputs.ingress_ip }}"
          
          if [ "$ENVIRONMENT" == "prod" ]; then
            DOMAIN="prod.lesaiglesbraves.online"
          else
            DOMAIN="dev.lesaiglesbraves.online"
          fi
          
          echo "## ðŸŽ‰ Deployment Successful - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Access Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain**: https://$DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "- **Ingress IP**: $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Update DNS record to point $DOMAIN to $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "2. Access ownCloud at https://$DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "3. Access Keycloak admin at https://$DOMAIN/auth" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Note**: Self-signed certificate in use. For production, configure Let's Encrypt." >> $GITHUB_STEP_SUMMARY

  # Job de nettoyage en cas d'Ã©chec
  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [set-environment, terraform, deploy-apps]
    if: failure() && github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    steps:
      - name: Failure Notification
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## âŒ Deployment Failed - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The deployment has failed. Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Troubleshooting Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Check Terraform output for infrastructure errors" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify Azure credentials and permissions" >> $GITHUB_STEP_SUMMARY
          echo "3. Check Ansible playbook logs for application deployment errors" >> $GITHUB_STEP_SUMMARY
          echo "4. Review Kubernetes events: \`kubectl get events -n owncloud\`" >> $GITHUB_STEP_SUMMARY
