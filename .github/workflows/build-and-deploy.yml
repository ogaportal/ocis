name: Build and Deploy

on:
  push:
    branches:
      - develop
      - main
  pull_request:
    branches:
      - develop
      - main

env:
  TERRAFORM_VERSION: '1.6.0'
  ANSIBLE_VERSION: '10.5.0'

jobs:
  # Job de build - Toujours exÃ©cutÃ© (mÃªme dans les PRs)
  build:
    name: Build and Validate
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        run: |
          echo "ðŸ” Checking Terraform format..."
          terraform fmt -check -recursive terraform/
        continue-on-error: true

      - name: Terraform Validate (Dev)
        working-directory: terraform/environments/dev
        run: |
          echo "âœ… Validating Dev environment..."
          terraform init -backend=false
          terraform validate

      - name: Terraform Validate (Prod)
        working-directory: terraform/environments/prod
        run: |
          echo "âœ… Validating Prod environment..."
          terraform init -backend=false
          terraform validate

      - name: Validate Kubernetes Manifests
        run: |
          echo "ðŸ” Validating Kubernetes manifests..."
          
          # Install kustomize
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          
          # Validate dev overlay
          echo "Validating dev overlay..."
          kustomize build k8s/overlays/dev > /dev/null
          
          # Validate prod overlay
          echo "Validating prod overlay..."
          kustomize build k8s/overlays/prod > /dev/null
          
          echo "âœ… All manifests are valid"

      - name: Validate Ansible Playbooks
        run: |
          echo "ðŸ” Validating Ansible playbooks..."
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          ansible-playbook ansible/deploy.yml --syntax-check
          ansible-playbook ansible/destroy.yml --syntax-check
          echo "âœ… All playbooks are valid"

      - name: Build Summary
        run: |
          echo "## ðŸŽ‰ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Terraform configuration valid" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Kubernetes manifests valid" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Ansible playbooks valid" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "â„¹ï¸ **Pull Request** - Deployment skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš€ **Branch: ${{ github.ref_name }}** - Deployment will proceed" >> $GITHUB_STEP_SUMMARY
          fi

  # DÃ©termine l'environnement basÃ© sur la branche
  set-environment:
    name: Set Environment
    runs-on: ubuntu-latest
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    needs: build
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    
    steps:
      - name: Determine Environment
        id: set-env
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "ðŸŒ Environment: **Production**" >> $GITHUB_STEP_SUMMARY
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "ðŸ§ª Environment: **Development**" >> $GITHUB_STEP_SUMMARY
          fi

  # VÃ©rification et gÃ©nÃ©ration des certificats
  check-certificates:
    name: Check and Generate Certificates
    runs-on: ubuntu-latest
    needs: set-environment
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Check Certificates in Key Vault
        id: check-certs
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          KEY_VAULT_NAME="owncloudkv${ENVIRONMENT}"
          
          echo "ðŸ” Checking certificates in Key Vault: $KEY_VAULT_NAME"
          
          # VÃ©rifier si les certificats existent en utilisant az keyvault certificate show
          KEYCLOAK_CERT=0
          OCIS_CERT=0
          KEYCLOAK_KEY=0
          OCIS_KEY=0
          
          if az keyvault certificate show --vault-name $KEY_VAULT_NAME --name keycloak-tls-cert &>/dev/null; then
            KEYCLOAK_CERT=1
          fi
          
          if az keyvault certificate show --vault-name $KEY_VAULT_NAME --name ocis-tls-cert &>/dev/null; then
            OCIS_CERT=1
          fi
          
          if az keyvault secret show --vault-name $KEY_VAULT_NAME --name keycloak-tls-key &>/dev/null; then
            KEYCLOAK_KEY=1
          fi
          
          if az keyvault secret show --vault-name $KEY_VAULT_NAME --name ocis-tls-key &>/dev/null; then
            OCIS_KEY=1
          fi
          
          if [ "$KEYCLOAK_CERT" -gt 0 ] && [ "$OCIS_CERT" -gt 0 ] && [ "$KEYCLOAK_KEY" -gt 0 ] && [ "$OCIS_KEY" -gt 0 ]; then
            echo "âœ… All certificates already exist in Key Vault"
            echo "  - keycloak-tls-cert: Found"
            echo "  - keycloak-tls-key: Found"
            echo "  - ocis-tls-cert: Found"
            echo "  - ocis-tls-key: Found"
            echo "certificates_exist=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Some certificates are missing in Key Vault"
            echo "  - keycloak-tls-cert: $([ $KEYCLOAK_CERT -gt 0 ] && echo 'Found' || echo 'Missing')"
            echo "  - keycloak-tls-key: $([ $KEYCLOAK_KEY -gt 0 ] && echo 'Found' || echo 'Missing')"
            echo "  - ocis-tls-cert: $([ $OCIS_CERT -gt 0 ] && echo 'Found' || echo 'Missing')"
            echo "  - ocis-tls-key: $([ $OCIS_KEY -gt 0 ] && echo 'Found' || echo 'Missing')"
            echo "certificates_exist=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Self-Signed Certificates
        if: steps.check-certs.outputs.certificates_exist == 'false'
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          
          if [ "$ENVIRONMENT" == "prod" ]; then
            DOMAIN="prod.lesaiglesbraves.online"
          else
            DOMAIN="dev.lesaiglesbraves.online"
          fi
          
          echo "ðŸ” Generating self-signed certificates for $DOMAIN"
          
          # CrÃ©er le rÃ©pertoire pour les certificats
          mkdir -p certs
          
          # GÃ©nÃ©rer le certificat Keycloak
          echo "Generating Keycloak certificate..."
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout certs/keycloak-tls.key \
            -out certs/keycloak-tls.crt \
            -subj "/C=FR/ST=France/L=Paris/O=OwnCloud/OU=IT/CN=$DOMAIN" \
            -addext "subjectAltName=DNS:$DOMAIN,DNS:*.$DOMAIN"
          
          # GÃ©nÃ©rer le certificat OCIS
          echo "Generating OCIS certificate..."
          openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
            -keyout certs/ocis-tls.key \
            -out certs/ocis-tls.crt \
            -subj "/C=FR/ST=France/L=Paris/O=OwnCloud/OU=IT/CN=$DOMAIN" \
            -addext "subjectAltName=DNS:$DOMAIN,DNS:*.$DOMAIN"
          
          # CrÃ©er des fichiers PFX pour Azure Key Vault
          echo "Creating PFX files..."
          openssl pkcs12 -export -out certs/keycloak-tls.pfx \
            -inkey certs/keycloak-tls.key -in certs/keycloak-tls.crt -passout pass:
          
          openssl pkcs12 -export -out certs/ocis-tls.pfx \
            -inkey certs/ocis-tls.key -in certs/ocis-tls.crt -passout pass:
          
          echo "âœ… Certificates generated successfully"

      - name: Upload Certificates to Key Vault
        if: steps.check-certs.outputs.certificates_exist == 'false'
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          KEY_VAULT_NAME="owncloudkv${ENVIRONMENT}"
          
          echo "ðŸ“¤ Uploading certificates to Key Vault: $KEY_VAULT_NAME"
          
          # Upload Keycloak certificate
          echo "Uploading Keycloak certificate..."
          az keyvault certificate import \
            --vault-name $KEY_VAULT_NAME \
            --name keycloak-tls-cert \
            --file certs/keycloak-tls.pfx
          
          az keyvault secret set \
            --vault-name $KEY_VAULT_NAME \
            --name keycloak-tls-key \
            --file certs/keycloak-tls.key \
            --content-type "application/x-pem-file"
          
          # Upload OCIS certificate
          echo "Uploading OCIS certificate..."
          az keyvault certificate import \
            --vault-name $KEY_VAULT_NAME \
            --name ocis-tls-cert \
            --file certs/ocis-tls.pfx
          
          az keyvault secret set \
            --vault-name $KEY_VAULT_NAME \
            --name ocis-tls-key \
            --file certs/ocis-tls.key \
            --content-type "application/x-pem-file"
          
          echo "âœ… All certificates uploaded successfully"
          
          # Nettoyer les fichiers locaux
          rm -rf certs

      - name: Certificate Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## ðŸ” Certificate Status - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.check-certs.outputs.certificates_exist }}" == "true" ]; then
            echo "âœ… Certificates already present in Key Vault" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ” New self-signed certificates generated and uploaded" >> $GITHUB_STEP_SUMMARY
          fi

  # DÃ©ploiement Terraform
  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [set-environment, check-certificates]
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    environment: ${{ needs.set-environment.outputs.environment }}
    env:
      ARM_CLIENT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientId }}
      ARM_CLIENT_SECRET: ${{ fromJson(secrets.AZURE_CREDENTIALS).clientSecret }}
      ARM_TENANT_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).tenantId }}
      ARM_SUBSCRIPTION_ID: ${{ fromJson(secrets.AZURE_CREDENTIALS).subscriptionId }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Terraform Init
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸ”§ Initializing Terraform for ${{ needs.set-environment.outputs.environment }}..."
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          if [ "$ENVIRONMENT" = "prod" ]; then
            SA_NAME="owncloudsastateprod"
          else
            SA_NAME="owncloudsastatedev"
          fi
          terraform init \
            -backend-config="storage_account_name=$SA_NAME" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=owncloud.tfstate"

      - name: Terraform Plan
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸ“‹ Creating Terraform plan..."
          terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: terraform/environments/${{ needs.set-environment.outputs.environment }}
        run: |
          echo "ðŸš€ Applying Terraform plan..."
          terraform apply -auto-approve tfplan

      - name: Get AKS Credentials
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "ðŸ”‘ Getting AKS credentials for $ENVIRONMENT..."
          az aks get-credentials \
            --resource-group owncloud-rg-$ENVIRONMENT \
            --name owncloud-aks-$ENVIRONMENT \
            --overwrite-existing

      - name: Infrastructure Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## ðŸ—ï¸ Infrastructure Deployed - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… AKS Cluster: owncloud-aks-$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Resource Group: owncloud-rg-$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Key Vault: owncloudkv$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Storage Account: owncloudstorages$ENVIRONMENT" >> $GITHUB_STEP_SUMMARY

  # DÃ©ploiement des applications
  deploy-apps:
    name: Deploy Applications
    runs-on: ubuntu-latest
    needs: [set-environment, terraform]
    # Seulement si pas une PR et branche develop ou main
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    environment: ${{ needs.set-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Ansible
        run: |
          pip install ansible==${{ env.ANSIBLE_VERSION }}
          ansible-galaxy collection install kubernetes.core
          ansible-galaxy collection install azure.azcollection

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          az aks get-credentials \
            --resource-group owncloud-rg-$ENVIRONMENT \
            --name owncloud-aks-$ENVIRONMENT \
            --overwrite-existing

      - name: Deploy Applications with Ansible
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "ðŸš€ Deploying applications to $ENVIRONMENT..."
          
          ansible-playbook \
            -i ansible/inventories/$ENVIRONMENT.yml \
            ansible/deploy.yml \
            -e "target_env=$ENVIRONMENT"

      - name: Wait for Deployments
        run: |
          echo "â³ Waiting for all pods to be ready..."
          
          # Afficher l'Ã©tat actuel
          echo "Current pods status:"
          kubectl get pods -n owncloud
          
          echo ""
          echo "Checking secrets..."
          kubectl get secrets -n owncloud
          
          echo ""
          echo "Checking SecretProviderClass..."
          kubectl get secretproviderclass -n owncloud
          
          # Attendre avec un timeout plus long
          echo ""
          echo "Waiting for pods to be ready (timeout: 10 minutes)..."
          kubectl wait --for=condition=ready pod --all -n owncloud --timeout=600s || true
          
          # Afficher les pods qui ne sont pas prÃªts
          echo ""
          echo "Final pod status:"
          kubectl get pods -n owncloud
          
          # Afficher les Ã©vÃ©nements pour debug
          echo ""
          echo "Recent events:"
          kubectl get events -n owncloud --sort-by='.lastTimestamp' | tail -20
          
          # VÃ©rifier si tous les pods sont ready
          NOT_READY=$(kubectl get pods -n owncloud --field-selector=status.phase!=Running -o name | wc -l)
          if [ $NOT_READY -gt 0 ]; then
            echo ""
            echo "âš ï¸ Warning: Some pods are not ready. Showing details:"
            kubectl describe pods -n owncloud | grep -A 10 "Events:"
            exit 1
          fi
          
          echo "âœ… All pods are ready!"

      - name: Get Service Information
        id: service-info
        run: |
          echo "ðŸ“Š Getting service information..."
          
          # Obtenir l'IP de l'Ingress
          INGRESS_IP=$(kubectl get ingress -n owncloud owncloud-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "ingress_ip=$INGRESS_IP" >> $GITHUB_OUTPUT
          
          # Lister tous les pods
          echo "### ðŸ“¦ Deployed Pods" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n owncloud >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Services" >> $GITHUB_STEP_SUMMARY
          kubectl get services -n owncloud >> $GITHUB_STEP_SUMMARY

      - name: Deployment Summary
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          INGRESS_IP="${{ steps.service-info.outputs.ingress_ip }}"
          
          if [ "$ENVIRONMENT" == "prod" ]; then
            DOMAIN="prod.lesaiglesbraves.online"
          else
            DOMAIN="dev.lesaiglesbraves.online"
          fi
          
          echo "## ðŸŽ‰ Deployment Successful - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Access Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain**: https://$DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "- **Ingress IP**: $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Update DNS record to point $DOMAIN to $INGRESS_IP" >> $GITHUB_STEP_SUMMARY
          echo "2. Access ownCloud at https://$DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "3. Access Keycloak admin at https://$DOMAIN/auth" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Note**: Self-signed certificate in use. For production, configure Let's Encrypt." >> $GITHUB_STEP_SUMMARY

  # Job de nettoyage en cas d'Ã©chec
  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [set-environment, terraform, deploy-apps]
    if: failure() && github.event_name != 'pull_request' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    
    steps:
      - name: Failure Notification
        run: |
          ENVIRONMENT="${{ needs.set-environment.outputs.environment }}"
          echo "## âŒ Deployment Failed - $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The deployment has failed. Please check the logs above for details." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Troubleshooting Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Check Terraform output for infrastructure errors" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify Azure credentials and permissions" >> $GITHUB_STEP_SUMMARY
          echo "3. Check Ansible playbook logs for application deployment errors" >> $GITHUB_STEP_SUMMARY
          echo "4. Review Kubernetes events: \`kubectl get events -n owncloud\`" >> $GITHUB_STEP_SUMMARY
